#!/usr/bin/env bash

# List of custom commands, space delimited.  This var should be
# updated by your resources/lib/[git-command] file
export __git_commands=""

# Return the list of custom commands.  This is also used for
# tab-completion
__git_autocomplete_commands() {
    echo "${__git_commands}"
}
export -f __git_autocomplete_commands

# Load all of the custom commands in resources/lib/.  These must be
# prefixed with 'git-'
for git_lib in $(find ${HOME}/.dotfiles/bash/lib/git-* -maxdepth 1 -not -type d -and -not -name '.*'); do
    source $git_lib
done

# git command wrapper + alias
#   Executes any custom commands found in the ./lib directory and
#   displays an interactive menu for "did you mean" error suggestions.
__git_better() {

    # Execute any command wrappers or extensions.
    custom_commands="$__git_commands"
    git_command=$(echo /usr/bin/env git "$@")
    custom_command_executed=0
    for a in ${custom_commands[@]}; do
        if [ "$1" = "$a" ]; then
            $(echo "git-$a" "${@:2}")
            custom_command_executed=1
            break
        fi
    done

    if [ 0 -eq $custom_command_executed ]; then
        local tmpfile=$(mktemp)
        /usr/bin/env git "$@" 2> $tmpfile
        exit_code=$?
        git_errors=$(cat $tmpfile)

        if [ "" != "$exit_code" ] && [ 0 -ne $exit_code ]; then
            # Display a menu for "did you mean" error suggestions
            if [ "" != "$(echo "$git_errors" | egrep -i "(Did you mean)|(The most similar command)")" ]; then
                reading_options=0
                local -a options
                while read -r line; do
                    line="$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
                    if [ "" = "$line" ]; then
                        reading_options=0
                    fi
                    if [ 1 -eq $reading_options ]; then
                        options+=($line)
                    fi
                    if [ "" != "$(echo "$line" | egrep -i "(Did you mean)|(The most similar command)")" ]; then
                        reading_options=1
                    fi
                done <<< "$git_errors"

                # rebuild git error output
                bad_command=$(echo "$git_errors" | awk -F "'" '{print $2}')
                >&2 echo "git: '$bad_command' is not a git command. See 'git --help'."
                >&2 echo

                # build error screen
                if [ 1 -eq "${#options[@]}" ]; then
                    >&2 echo "    Did you mean this?"
                else
                    >&2 echo "    Did you mean one of these?"
                fi

                # build menu items
                local cnt=0
                for a in "${options[@]}"; do
                    if [ 1 -eq "${#options[@]}" ]; then
                        opt_key=""
                    else
                        opt_key="$((cnt + 1)):"
                    fi
                    >&2 echo "        $opt_key ${options[$cnt]}"
                    cnt=$((cnt + 1))
                done
                >&2 echo

                # prompt for input
                old_IFS=$IFS
                IFS='%'
                if [ 1 -eq $cnt ]; then
                    prompt="[Y/n] > "
                else
                    >&2 echo "        0: quit"
                    >&2 echo
                    prompt="[1] > "
                fi
                read -e -p $prompt -t 60 option
                IFS=$old_IFS

                # if input is not no/quit
                if [ "0" != "$option" ] && [ "n" != "$option" ] && [ "N" != "$option" ]; then
                    # set default option if none given
                    if [ "" = "$option" ] || [ "Y" = "$option" ] || [ "y" = "$option" ]; then
                        option=1
                    fi
                    # exec
                    option=$((option - 1))
                    shift
                    echo "executing /usr/bin/env git ${options[$option]} $@"
                    echo
                    /usr/bin/env git ${options[$option]} "$@"
                fi
            else
                echo "$git_errors"
                return $exit_code
            fi
        fi
    fi
}

export -f __git_better
alias git='__git_better'

__gi() {
    if [ "tpush" = "$1" ]; then
        shift
        git push $@
    else
        echo "that's not a thing..."
    fi
}
export -f __gi
alias gi='__gi'